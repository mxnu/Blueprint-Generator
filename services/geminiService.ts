import { GoogleGenAI, Modality } from "@google/genai";

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
    throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

/**
 * Generates an image based on a text prompt.
 * @param prompt The text prompt for image generation.
 * @returns A base64 encoded string of the generated JPEG image.
 */
export const generateImage = async (prompt: string): Promise<string> => {
    try {
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: {
                numberOfImages: 1,
                outputMimeType: 'image/jpeg',
                aspectRatio: '1:1',
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
            return response.generatedImages[0].image.imageBytes;
        } else {
            throw new Error("No image was generated by the API.");
        }
    } catch (error) {
        console.error("Error in generateImage:", error);
        throw new Error("Failed to communicate with the Gemini API for image generation.");
    }
};

/**
 * Applies a given artistic style to an existing image.
 * @param base64ImageData The base64 encoded source image data.
 * @param mimeType The MIME type of the source image.
 * @param styleModifier The prompt describing the style to apply.
 * @returns A base64 encoded string of the newly styled PNG image, or null.
 */
export const applyStyleToImage = async (base64ImageData: string, mimeType: string, styleModifier: string): Promise<string | null> => {
    try {
        const prompt = `Isolate the main subject from this image, completely removing its original background. Place the isolated subject on a clean, solid, light gray background. Then, re-render the subject to look like a 3D model, faithfully applying the following artistic aesthetic: "${styleModifier}". The new image must retain the original subject's pose, composition, and core identity. Ensure the output is a high-quality, centered image of only the subject, without any original background elements, text, or annotations.`;

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: {
                parts: [
                    { inlineData: { data: base64ImageData, mimeType: mimeType } },
                    { text: prompt },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        if (response.candidates?.[0]?.content?.parts) {
            for (const part of response.candidates[0].content.parts) {
                if (part.inlineData) {
                    return part.inlineData.data;
                }
            }
        }
        
        console.warn(`No image part returned for style application.`);
        return null;

    } catch (error) {
        console.error(`Error in applyStyleToImage:`, error);
        throw new Error(`Failed to apply style to the image.`);
    }
};


/**
 * Generates a specific blueprint view from a source image.
 * @param base64ImageData The base64 encoded source image data.
 * @param mimeType The MIME type of the source image.
 * @param view The blueprint view to generate (e.g., 'front view').
 * @returns A base64 encoded string of the generated PNG blueprint image, or null if no image part is returned.
 */
export const generateBlueprintView = async (base64ImageData: string, mimeType: string, view: string): Promise<string | null> => {
    try {
        let specificInstruction = '';
        switch (view) {
            case 'front view':
                specificInstruction = `This view must show the object from the front, as if looking directly at its face. The subject must maintain its original pose.`;
                break;
            case 'side view (right)':
                specificInstruction = `This view must show the object from its right-hand side, a 90-degree turn from the front view. The subject must maintain its original pose.`;
                break;
            case 'side view (left)':
                specificInstruction = `This is a technical orthographic projection from the subject's left side. It must show the object as if viewed after a -90 degree (counter-clockwise) rotation from the front. The subject must maintain its original pose.`;
                break;
            case 'back view':
                specificInstruction = `This is a technical rear orthographic projection. It must show the object from directly behind, a 180-degree turn from the front view. The output must be a flat, 2D elevation view with no perspective. The subject must maintain its original pose. Do not include any background or environmental elements.`;
                break;
            case 'top view':
                specificInstruction = `This is a technical top-down orthographic projection. It must show the object as if viewed from directly above at a 90-degree angle. The subject's pose and orientation on the ground must remain identical to the source image. Do not make the subject look up or change its stance.`;
                break;
            default:
                specificInstruction = `This is the ${view}.`;
        }

        const prompt = `Generate a technical wireframe blueprint of the main subject's ${view}. ${specificInstruction} The output must be a monochromatic wireframe or line drawing with black lines on a solid white background. ABSOLUTELY NO colors, shading, or textures should be present. This is a technical drawing for 3D modeling, not an artistic render. Do not include any text, dimensions, annotations, or shadows.`;


        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: base64ImageData,
                            mimeType: mimeType,
                        },
                    },
                    {
                        text: prompt,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        if (response.candidates && response.candidates[0] && response.candidates[0].content && response.candidates[0].content.parts) {
            for (const part of response.candidates[0].content.parts) {
                if (part.inlineData) {
                    return part.inlineData.data;
                }
            }
        }
        
        console.warn(`No image part returned for ${view}.`);
        return null;

    } catch (error) {
        console.error(`Error in generateBlueprintView for ${view}:`, error);
        throw new Error(`Failed to generate the ${view} blueprint.`);
    }
};